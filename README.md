# Comet

---

## 프로젝트 개요

Comet은 Unity 엔진으로 제작한 3D TPS 로그라이크 게임으로,  
아래와 같은 목표를 중심으로 개발되었습니다.

1. 다수의 적/투사체가 등장하는 환경에서의 메모리 및 퍼포먼스 최적화
2. 확장과 수정에 용이한 설계(OOP / SOLID, 상태 패턴 등) 적용
3. 데이터 저장/불러오기 시스템을 통한 유저 설정 관리
4. 유지보수가 쉬운 상태 기반(FSM) 구조 설계

- [게임 플레이 영상](https://youtu.be/086iRNFH7NM)
- [프로젝트 기술서](https://drive.google.com/file/d/16mcWP2yKtXzaJmvNjsGbU_zn3mou_Yr6/view?usp=drive_link)

---

## 기술 스택

- **개발 언어**
  - C#

- **엔진 / 개발 도구**
  - Unity
  - Visual Studio

- **버전 관리**
  - Git / GitHub

---

## 주요 기술

### 1) 메모리 최적화 (ScriptableObject, Object Pool)

#### ScriptableObject

- 로그라이크 특성상 다양한 적, 플레이어 캐릭터, 아이템이 다량으로 등장하기 때문에
  각종 스탯/설정을 ScriptableObject로 분리하여 관리했습니다.
- 런타임에 불필요한 사본 생성을 줄이고,  
  원본 데이터를 참조하는 방식으로 메모리 사용량을 절감했습니다.
- 몬스터, 플레이어, 아이템처럼 추가·수정이 잦은 데이터를 중심으로 ScriptableObject를 적용했습니다.

#### Object Pool

- `Instantiate / Destroy`와 GC 비용이 프레임 드롭을 유발할 수 있다고 판단하여
  **Object Pool 패턴**을 적용했습니다.
- 씬 로드 시 정해진 수량만큼 미리 생성해 두고,
  - 필요할 때 활성화하여 사용
  - 사용이 끝나면 파괴하지 않고 비활성화 후 풀에 반환
- 사전 생성 수량을 초과하는 경우에만 추가로 Instantiate하고,  
  이 역시 비활성화하여 재사용 가능한 상태로 유지하도록 구현했습니다.

---

### 2) 데이터 관리 (Singleton + JSON 저장/불러오기)

#### Singleton Pattern

- 프로그램 내에서 **하나의 인스턴스로 관리해야 하는 데이터**에 대해 Singleton 패턴을 사용했습니다.
- 프로젝트에서는 특히:
  - 플레이어가 선택한 캐릭터 정보
  - 설정 UI에서 지정한 감도, 볼륨 등 환경설정 값
  을 중심으로 Singleton + `DontDestroyOnLoad`를 함께 사용해 씬 전환에도 유지되도록 했습니다.
- Singleton에 과도한 데이터가 몰리지 않도록,  
  필수 전역 상태만 맡도록 역할을 제한했습니다.

#### JSON 기반 저장/불러오기

- 플레이어 설정을 매번 다시 조정하지 않도록  
  **JSON 파일**로 저장/로드하는 기능을 구현했습니다.
- Unity의 `JsonUtility`를 이용하여:
  - 해상도/감도/볼륨 등 **유저 설정 값**을 구조체/클래스로 정의
  - 애플리케이션 경로 하위(JSON 파일)에 저장
  - 게임 실행 시 해당 파일을 읽어 자동으로 설정을 복원
- JSON 형식은 가독성이 좋고 다른 플랫폼과의 호환성이 좋다는 점을 고려해 선택했습니다.

---

### 3) 상태 관리 (FSM / State Pattern)

- 플레이어 및 적 캐릭터의 행동은 FSM(Finite State Machine) 기반으로 구성했습니다.
- 각 상태(예: Idle, Move, Attack, Dead 등)를 별도의 클래스/스크립트로 분리하여
  - 상태별 로직을 독립적으로 관리
  - 새로운 행동 추가 시 해당 상태에만 기능을 추가하면 되도록 설계
- 이 구조를 통해 다음과 같은 효과를 얻을 수 있었습니다.
  - 코드 가독성 향상
  - 상태 전환 흐름을 직관적으로 파악 가능
  - 특정 행동 수정 시 다른 상태에 대한 영향 최소화가 가능해졌습니다.

---

### 4) 설계 원칙 (OOP / SOLID)

- 기능 확장과 수정을 염두에 두고 객체지향(OOP)과 SOLID 원칙을 학습·적용했습니다.
- 주요 방향:
  - **캡슐화**: 프로퍼티를 활용해 내부 데이터를 보호하고, 필요한 인터페이스만 외부에 공개
  - **상속/구현**: 공통 로직은 상위 클래스나 인터페이스로 추상화하여  
    유사한 객체(여러 종류의 적/아이템 등)를 손쉽게 추가 가능하도록 설계
  - **단일 책임 원칙(SRP)**: 이동, 공격, 상태 관리, 데이터 관리 등을 서로 다른 컴포넌트로 분리

---

### 5) Audio & Shader

#### Audio (Audio Mixer)

- Unity Audio Mixer를 사용하여:
  - 배경음(BGM)
  - 효과음(SFX)
  을 별도의 그룹으로 관리했습니다.
- 플레이어가 옵션 UI에서 BGM / 효과음을 개별적으로 조절할 수 있도록 구성했습니다.

#### Shader (Dissolve 효과)

- 오브젝트가 소멸할 때 자연스러운 연출을 위해 Dissolve Shader를 사용했습니다.
- 특정 Noise 텍스처와 Amount 값을 기반으로  
  오브젝트가 서서히 사라지는 효과를 구현했습니다.

---

## 기대 효과

### 메모리 및 성능 최적화

- ScriptableObject와 Object Pool 적용으로  
  불필요한 메모리 할당과 해제를 줄여 런타임 성능을 개선할 수 있습니다.

### 유지보수 및 확장성

- FSM(State Pattern)과 OOP/SOLID 원칙을 적용한 구조 덕분에
  - 새로운 적/패턴/아이템 추가
  - 기존 행동 수정 시 코드 변경 범위를 최소화하여 유지보수가 용이합니다.

### 안정적인 데이터 관리

- JSON 기반 저장/불러오기 시스템을 통해  
  유저 설정 데이터를 안정적으로 관리하고,  
  실행 간 일관된 플레이 환경을 제공할 수 있습니다.
